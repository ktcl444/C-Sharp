///////////////////////////////////////////////////////////////////////////////
// Microsoft Solutions for Security
// Copyright (c) 2004 Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
// WHETHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
// THE ENTIRE RISK OF USE OR RESULTS IN CONNECTION WITH THE USE OF THIS CODE
// AND INFORMATION REMAINS WITH THE USER.
///////////////////////////////////////////////////////////////////////////////

using System;
using System.Security.Cryptography;
using System.Text;

namespace PasswordGenerator
{
	/// <summary>
	/// This class is to generate Initial password when an ID
	/// is created for a new employee. The password should also
	/// confine to the password policy of the domain forest
	/// </summary>

	public class PasswordGenerator
	{
		public PasswordGenerator() 
		{
			// Instantiate a cryptographic Random Number Generator
			// using implementation provided by cryptographic service provider 
			rnGenerator = new RNGCryptoServiceProvider();			
		}		
		     
		// Declarations				
		private RNGCryptoServiceProvider    rnGenerator;                       
		private char[] pwdCharArray = ("abcdefghjkmnopqrstuvwxyzABCDEFG" +
						"HJKLMNPQRSTUVWXYZ23456789").ToCharArray();   
		
		/// <summary>
		/// Gets cryptographically strong 
		/// random numbers to support password generation
		/// </summary>
		/// <param name="lBound">Lower Bound</param>
		/// <param name="uBound">Upper Bound</param>
		/// <returns>integers</returns>
		protected int GetCryptographicRandomNumber(int lBound, int uBound)
		{ 
  			// Assumes lBound >= 0 && lBound < uBound
			// returns an int >= lBound and < uBound
			uint urndNumber;   
			byte[] rndNumber = new Byte[4];   
			if (lBound == uBound-1)  
			{
				// test for degenerate case where only lBound can be returned
				return lBound;
			}
                                                              
			uint xcludeRndBase = (uint.MaxValue -
				(uint.MaxValue%(uint)(uBound-lBound)));
			do 
			{      
				// fill with cryptographically strong random bytes
				rnGenerator.GetBytes(rndNumber);
				urndNumber = System.BitConverter.ToUInt32(rndNumber,0);     
			} while (urndNumber >= xcludeRndBase);   
        
			return (int)(urndNumber % (uBound-lBound)) + lBound;

		}

		/// <summary>
		/// This method is to obtain a random character
		/// and determine its position in the password
		/// </summary>
		/// <returns>character</returns>
		protected char GetRandomCharacter()
		{            
			int upperBound = pwdCharArray.GetUpperBound(0);

			// Determine the position of the random number
			int randomCharPosition = GetCryptographicRandomNumber(
				pwdCharArray.GetLowerBound(0), upperBound);
		
			// Assign a random variable
			char randomChar = pwdCharArray[randomCharPosition];

			return randomChar;
		}
        
		/// <summary>
		/// Generates the password
		/// with the attributes generated by methods like
		/// GetRandomCharacter and GetCryptographicRandomNumber
		/// </summary>
		/// <param name="pwdLength">Length of the password</param>
		/// <returns>string</returns>
		public string Generate(int pwdLength)
		{
			// Pick random length between minimum and maximum   			
			StringBuilder pwdBuffer = new StringBuilder();
			pwdBuffer.Capacity = pwdLength;

			// Generate random characters
			char lastCharacter, nextCharacter;

			// Initial dummy character flag
			lastCharacter = nextCharacter = '\n';

			for ( int i = 0; i < pwdLength; i++ )
			{
				// Generate random characters one by one and
				// append it to the pwd buffer
				nextCharacter = GetRandomCharacter();
				pwdBuffer.Append(nextCharacter);
				lastCharacter = nextCharacter;
			}

			// Check for the pwdBuffer not to be null and
			// then return it
			if ( pwdBuffer != null )
			{
				return pwdBuffer.ToString();
			}
			else
			{
				return String.Empty;
			}	
		}
  	}

}
